-- Carga de la UI/HUD
local RainbowUI = loadstring(game:HttpGet("https://raw.githubusercontent.com/GAMER12VIP/NUEVO/refs/heads/main/Library"))()
local hud = RainbowUI:CreateWindow() -- no necesitas poner t칤tulo

local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- =========================
-- Variables y utilidades
-- =========================

-- Variables de control (bot칩n BUSCAR)
local teleporting = false
local teleportObjectName = nil
local notifiedNoObjects = false
local notifiedError = false
local TELEPORT_INTERVAL = 0.1 -- ajustado a 0.1s para respuesta r치pida

-- (Auto-win eliminado: ahora es manual mediante bot칩n)

-- Variables de control (ciclo PICKUPS) - hacen UNA pasada y paran
local multiTeleporting = false
local multiCancelRequested = false
local MULTI_TELEPORT_INTERVAL = 2.0 -- segundos entre cada teletransporte (de 2.0s)
local multiNotifiedNoObjects = false
local multiNotifiedError = false
local multiPickupSlotNames = {
    "RevealPickupsSteveEagle",
    "RevealPickupsSteveGecko",
    "RevealPickupsSteveMantisShrimp",
    "RevealPickupsSteveSnowLeopard",
}

-- Variables de control (ciclo STICKERS) - hacen UNA pasada y se detienen
local stickerTeleporting = false
local stickerCancelRequested = false
local STICKER_TELEPORT_INTERVAL = 2.0 -- segundos entre cada teletransporte (menos de 2.0s)
local stickerNotifiedNoObjects = false
local stickerNotifiedError = false

-- Lista de rutas relativas a workspace (sin el prefijo "workspace.")
local stickerPaths = {
    "Stickers.Cheetah.CheckpointNoSticker00A",
    "ActiveStickers.d6001",
    "Stickers.Cheetah.CheckpointNoSticker01A",
    "Stickers.Cheetah.CheckpointNoSticker01B",
    "ActiveStickers.d6002",
    "Stickers.Cheetah.CheckpointNoSticker02A",
    "ActiveStickers.d6003",
    "ActiveStickers.d6004",
    "ActiveStickers.d6005",
    "ActiveStickers.d6006",
    "Stickers.SnowLeopard.CheckpointNoSticker06A",
    "Stickers.SnowLeopard.CheckpointNoSticker06B",
    "ActiveStickers.d6007",
    "Stickers.SnowLeopard.CheckpointNoSticker07A",
    "ActiveStickers.d6008",
    "Stickers.SnowLeopard.CheckpointNoSticker08A",
    "ActiveStickers.d6009",
    "Stickers.SnowLeopard.CheckpointNoSticker09A",
    "ActiveStickers.d6010",
    "ActiveStickers.d6011",
    "ActiveStickers.d6012",
    "Stickers.Eagle.CheckpointNoSticker12A",
    "Stickers.Eagle.CheckpointNoSticker12A",
    "Stickers.Eagle.CheckpointNoSticker12B",
    "ActiveStickers.d6013",
    "Stickers.Eagle.CheckpointNoSticker13A",
    "Stickers.Eagle.CheckpointNoSticker14A",
    "ActiveStickers.d6014",
    "ActiveStickers.d6015",
}

-- =========================
-- Plataforma anti-ca칤da (piso m칩vil)
-- - Sigue solo X/Z del jugador para NO provocar "fly".
-- - Se reposiciona en Y SOLO en teletransporte o al crearla/manual.
-- - Ahora soporta FORCE DISABLE: si la desactivas manualmente se destruye y no se recrea hasta que la vuelvas a activar.
-- =========================

local platform = nil
local platformFollowConn = nil
local platformManualEnabled = false -- si true, la plataforma persiste aunque no haya teletransporte
local platformForceDisabled = false -- si true, evita que se cree autom치ticamente (forzado por el usuario)
local PLATFORM_SIZE = Vector3.new(6, 1, 6) -- ajusta tama침o del piso
local PLATFORM_TRANSPARENCY = 0.35
local PLATFORM_COLOR = Color3.fromRGB(30, 144, 255) -- azul
local platformYOffset = 0.1 -- se calcula al crearla; distancia entre HRP y centro de la plataforma

local function destroyPlatform()
    if platformFollowConn then
        pcall(function() platformFollowConn:Disconnect() end)
        platformFollowConn = nil
    end
    if platform and platform.Parent then
        pcall(function() platform:Destroy() end)
    end
    platform = nil
    if hud and hud.Notify then hud:Notify("Plataforma desactivada") end
end

local function createPlatform()
    -- Si el usuario forz칩 desactivar, no crear
    if platformForceDisabled then return end

    -- Si ya existe, no crear otra
    if platform and platform.Parent then return end
    local character = LocalPlayer and LocalPlayer.Character
    if not character then return end
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    -- Crear la parte
    local p = Instance.new("Part")
    p.Name = "TeleportPlatform_" .. tostring(LocalPlayer and LocalPlayer.UserId or "Local")
    p.Size = PLATFORM_SIZE
    p.Anchored = true
    p.CanCollide = true
    p.Transparency = PLATFORM_TRANSPARENCY
    p.Material = Enum.Material.SmoothPlastic
    p.Color = PLATFORM_COLOR
    p.TopSurface = Enum.SurfaceType.Smooth
    p.BottomSurface = Enum.SurfaceType.Smooth
    p.Parent = workspace

    -- Posicionar inicialmente justo debajo del HumanoidRootPart (centro de la parte)
    local hrpSizeY = (hrp.Size and hrp.Size.Y) or 2
    local yOffset = (hrpSizeY / 2) + (p.Size.Y / 2) + 0.1
    platformYOffset = yOffset
    p.CFrame = CFrame.new(hrp.Position - Vector3.new(0, yOffset, 0))

    platform = p

    -- Seguir al jugador cada frame SOLO en X/Z (mantener Y fijo)
    platformFollowConn = RunService.Heartbeat:Connect(function()
        if not LocalPlayer or not LocalPlayer.Character then
            destroyPlatform()
            return
        end
        local curHrp = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if not curHrp then
            destroyPlatform()
            return
        end
        -- Mantener Y actual de la plataforma, pero mover X,Z para seguir al HRP
        local currentY = platform and platform.Parent and platform.Position.Y or (curHrp.Position.Y - platformYOffset)
        local targetPos = Vector3.new(curHrp.Position.X, currentY, curHrp.Position.Z)
        platform.CFrame = CFrame.new(targetPos)
    end)

    if hud and hud.Notify then hud:Notify("Plataforma activada") end
end

-- Comprueba si debe haber plataforma activa (teleports activos o toggle manual)
local function updatePlatformState()
    -- Si el usuario forz칩 desactivar, aseg칰rate de destruir y no recrear.
    if platformForceDisabled then
        if platform and platform.Parent then
            pcall(destroyPlatform)
        end
        return
    end

    if teleporting or multiTeleporting or stickerTeleporting or platformManualEnabled then
        if not platform or not platform.Parent then
            pcall(createPlatform)
        end
    else
        -- Ninguna operaci칩n activa y no est치 en modo manual -> destruir plataforma
        if platform and platform.Parent then
            pcall(destroyPlatform)
        end
    end
end

-- Asegurarse de recrear plataforma si el personaje reaparece (solo si no fue forzada a off)
if LocalPlayer then
    LocalPlayer.CharacterAdded:Connect(function(char)
        wait(0.1)
        if platform and platform.Parent then
            -- si hab칤a plataforma, recrearla para el nuevo character
            pcall(destroyPlatform)
            wait(0.05)
            pcall(function()
                if not platformForceDisabled then createPlatform() end
            end)
        end
    end)
end

-- Mueve la plataforma directamente debajo del jugador (incluye Y) - usar en teletransportes
local function ensurePlatformUnderCharacterInstant()
    if not platform or not platform.Parent then return end
    local character = LocalPlayer and LocalPlayer.Character
    if not character then return end
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    local yOffset = platformYOffset or (((hrp.Size and hrp.Size.Y) or 2) / 2 + (platform.Size.Y / 2) + 0.1)
    platform.CFrame = CFrame.new(hrp.Position - Vector3.new(0, yOffset, 0))
end

-- =========================
-- Funci칩n GANAR reutilizable (ahora s칩lo manual)
-- =========================
local function doWinTeleport()
    local player = LocalPlayer
    local success, destination = pcall(function()
        return game.Workspace.Utility.Teleporters.Portal_to_Wc.Portal["Canvas Clouds"]:FindFirstChild("Cylinder")
    end)

    if success and destination then
        pcall(function()
            if player and player.Character and player.Character.PrimaryPart then
                player.Character:SetPrimaryPartCFrame(destination.CFrame)
                -- Ajustar plataforma inmediatamente
                pcall(ensurePlatformUnderCharacterInstant)
                if hud and hud.Notify then hud:Notify("Teletransportado a GANAR") end
            end
        end)
    else
        if hud and hud.Notify then hud:Notify("Destino GANAR no encontrado") end
    end
end

-- =========================
-- Funciones de teletransporte
-- =========================

local function teleportToInstance(instance)
    if not instance then return false end

    local targetCFrame = nil
    if instance:IsA("BasePart") then
        targetCFrame = instance.CFrame
    elseif instance:IsA("Model") and instance.PrimaryPart then
        targetCFrame = instance.PrimaryPart.CFrame
    end

    if targetCFrame then
        local success, err = pcall(function()
            local player = LocalPlayer
            if player and player.Character and player.Character.PrimaryPart then
                player.Character:SetPrimaryPartCFrame(targetCFrame)
                -- Mover plataforma inmediatamente con el personaje (incluye Y) para evitar ca칤da
                pcall(ensurePlatformUnderCharacterInstant)
            end
        end)

        if not success then
            return false
        end

        return true
    end

    return false
end

local function teleportToObject(objectName)
    if not objectName then return false end

    local pickupsFolder = game.Workspace:FindFirstChild("Pickups")
    if not pickupsFolder then
        return false
    end

    local object = pickupsFolder:FindFirstChild(objectName)
    if not object then
        return false
    end

    if object:IsA("Model") and object.PrimaryPart then
        return teleportToInstance(object.PrimaryPart)
    else
        return teleportToInstance(object)
    end
end

-- =========================
-- Bucle BUSCAR (mantiene loop hasta toggle)
-- - Ya NO inicia auto-win; ahora "GANAR" se realiza manual con el bot칩n.
-- =========================

local function startTeleportLoop()
    spawn(function()
        while teleporting do
            local found = teleportToObject(teleportObjectName)

            if found then
                -- Notificar que se encontr칩 el objeto (no se programa auto-win)
                if hud and hud.Notify then hud:Notify("Objeto encontrado (auto-win desactivado). Usa el bot칩n GANAR para teletransportarte.") end
                if notifiedNoObjects then notifiedNoObjects = false end
            else
                if not notifiedNoObjects and hud and hud.Notify then
                    hud:Notify("No hay objetos")
                    notifiedNoObjects = true
                end
            end

            wait(TELEPORT_INTERVAL)
        end
        -- Si se detiene la b칰squeda, actualizar plataforma
        updatePlatformState()
    end)
end

local function toggleTeleporting(objectName)
    if teleporting then
        -- detener b칰squeda
        teleporting = false
        teleportObjectName = nil
        if hud and hud.Notify then hud:Notify("Opci칩n desactivada") end
        notifiedNoObjects = false
        notifiedError = false
    else
        -- iniciar b칰squeda
        teleportObjectName = objectName
        teleporting = true
        startTeleportLoop()
        if hud and hud.Notify then hud:Notify("B칰squeda activada (auto-win eliminado; usa el bot칩n GANAR para teletransportarte manualmente)") end
    end
    updatePlatformState()
end

-- =========================
-- Bucle PICKUPS (UNA pasada garantizada de primero a 칰ltimo)
-- =========================

local function gatherMultiTargets()
    local targets = {}
    local slotsRoot = workspace:FindFirstChild("PickupSlots")
    if not slotsRoot then return targets end

    for _, slotName in ipairs(multiPickupSlotNames) do
        local slot = slotsRoot:FindFirstChild(slotName)
        if slot then
            local def = slot:FindFirstChild("Default")
            if def then
                table.insert(targets, def)
            end
        end
    end

    return targets
end

local function startMultiTeleportOnce()
    spawn(function()
        -- Tomar snapshot de targets al iniciar la pasada para garantizar orden
        local targets = gatherMultiTargets()

        if #targets == 0 then
            if not multiNotifiedNoObjects and hud and hud.Notify then
                hud:Notify("No hay pickups disponibles en PickupSlots")
                multiNotifiedNoObjects = true
            end
            multiTeleporting = false
            if hud and hud.Notify then hud:Notify("Ciclo de pickups finalizado (sin targets)") end
            updatePlatformState()
            return
        else
            if multiNotifiedNoObjects then multiNotifiedNoObjects = false end
        end

        -- Garantizar que se recorre desde el primero hasta el 칰ltimo (aunque alg칰n teleport falle,
        -- se contin칰a con el siguiente)
        for i = 1, #targets do
            local target = targets[i]

            -- Intentar teletransportar (si falla, se registra el error y se pasa al siguiente)
            local ok = false
            local success, err = pcall(function()
                ok = teleportToInstance(target)
            end)
            if (not success) or (success and ok == false) then
                if not multiNotifiedError and hud and hud.Notify then
                    hud:Notify("Error o pickup no v치lido en 칤ndice " .. tostring(i))
                    multiNotifiedError = true
                end
            else
                if hud and hud.Notify then
                    hud:Notify("Teletransportado a pickup (" .. tostring(i) .. "): " .. tostring(target.Name or "Pickup"))
                end
                if multiNotifiedError then multiNotifiedError = false end
            end

            -- Esperar exactamente el intervalo configurado antes del siguiente teletransporte
            wait(MULTI_TELEPORT_INTERVAL)
        end

        -- pasada completa terminada
        multiTeleporting = false
        multiCancelRequested = false
        if hud and hud.Notify then hud:Notify("Ciclo de pickups finalizado (pasada completa)") end
        updatePlatformState()
    end)
end

local function toggleMultiTeleport()
    if multiTeleporting then
        -- Solicitud de cancelaci칩n: la pasada actual seguir치 hasta el final pero no se reiniciar치
        multiCancelRequested = true
        if hud and hud.Notify then hud:Notify("Solicitud de cancelaci칩n recibida: la pasada terminar치 y luego se detendr치") end
    else
        -- Si el usuario previamente forz칩 la plataforma OFF y quiere ejecutar la pasada,
        -- la pasada puede correr sin crear plataforma autom치tica; eso es respetado.
        multiTeleporting = true
        multiCancelRequested = false
        if hud and hud.Notify then hud:Notify("Iniciando pasada de pickups (se recorrer치 completo)") end
        startMultiTeleportOnce()
    end
    updatePlatformState()
end

-- =========================
-- Bucle STICKERS (UNA pasada garantizada de primero a 칰ltimo)
-- =========================

local function findNodeByPath(path)
    local node = workspace
    for seg in string.gmatch(path, "[^%.]+") do
        if node then
            node = node:FindFirstChild(seg)
        else
            break
        end
    end
    return node
end

local function gatherStickerTargets()
    local targets = {}
    for _, relPath in ipairs(stickerPaths) do
        local node = findNodeByPath(relPath)
        if node then
            local touch = node:FindFirstChild("Touch")
            if touch then
                table.insert(targets, touch)
            end
        end
    end
    return targets
end

local function startStickerTeleportOnce()
    spawn(function()
        local targets = gatherStickerTargets()

        if #targets == 0 then
            if not stickerNotifiedNoObjects and hud and hud.Notify then
                hud:Notify("No hay stickers disponibles")
                stickerNotifiedNoObjects = true
            end
            stickerTeleporting = false
            if hud and hud.Notify then hud:Notify("Ciclo de stickers finalizado (sin targets)") end
            updatePlatformState()
            return
        else
            if stickerNotifiedNoObjects then stickerNotifiedNoObjects = false end
        end

        for i = 1, #targets do
            local target = targets[i]

            local ok = false
            local success, err = pcall(function()
                ok = teleportToInstance(target)
            end)
            if (not success) or (success and ok == false) then
                if not stickerNotifiedError and hud and hud.Notify then
                    hud:Notify("Error o sticker no v치lido en 칤ndice " .. tostring(i))
                    stickerNotifiedError = true
                end
            else
                if hud and hud.Notify then
                    hud:Notify("Teletransportado a sticker (" .. tostring(i) .. "): " .. tostring(target.Name or "Sticker"))
                end
                if stickerNotifiedError then stickerNotifiedError = false end
            end

            -- Esperar intervalo entre teleports
            wait(STICKER_TELEPORT_INTERVAL)
        end

        stickerTeleporting = false
        stickerCancelRequested = false
        if hud and hud.Notify then hud:Notify("Ciclo de stickers finalizado (pasada completa)") end
        updatePlatformState()
    end)
end

local function toggleStickerTeleport()
    if stickerTeleporting then
        -- Solicitud de cancelaci칩n pero permitir que la pasada termine
        stickerCancelRequested = true
        if hud and hud.Notify then hud:Notify("Solicitud de cancelaci칩n recibida: la pasada terminar치 y luego se detendr치") end
    else
        stickerTeleporting = true
        stickerCancelRequested = false
        if hud and hud.Notify then hud:Notify("Iniciando pasada de stickers (se recorrer치 completo)") end
        startStickerTeleportOnce()
    end
    updatePlatformState()
end

-- =========================
-- Botones en la UI
-- =========================

hud:AddButton("BUSCAR 游댍", function()
    local objectNames = {"Default"} -- cambia seg칰n necesites
    local firstObjectName = objectNames[1]
    toggleTeleporting(firstObjectName)
end)

hud:AddButton("CICLO PICKUPS 游대", function()
    toggleMultiTeleport()
end)

hud:AddButton("CICLO STICKERS 游대", function()
    toggleStickerTeleport()
end)

-- Bot칩n para activar/desactivar la plataforma manualmente
hud:AddButton("PLATAFORMA 游릱", function()
    -- Toggle manual mode:
    if not platformManualEnabled then
        -- Activar manual: permite creaci칩n y quita la fuerza de OFF
        platformManualEnabled = true
        platformForceDisabled = false
        pcall(createPlatform)
        if hud and hud.Notify then hud:Notify("Plataforma manual: ON") end
    else
        -- Desactivar manual: forzar OFF aunque teleports est칠n activos
        platformManualEnabled = false
        platformForceDisabled = true
        -- Destruye inmediatamente la plataforma y evita recrearla autom치ticamente
        pcall(destroyPlatform)
        if hud and hud.Notify then hud:Notify("Plataforma manual: OFF (forzada)") end
    end
    updatePlatformState()
end)

hud:AddButton("GANAR 游끠", function()
    doWinTeleport()
end)
